<!-- public/client.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SecureChat v2</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f4f4f4; }
    #chat-container { display: flex; flex-direction: column; height: 90vh; }
    #message-area { flex: 1; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #fff; margin-bottom: 10px; }
    #user-list { margin-bottom: 10px; }
    #input-area { display: flex; gap: 10px; }
    input, select, textarea, button { padding: 8px; font-size: 1em; }
    textarea { flex: 1; resize: none; }
  </style>
</head>
<body>
  <h2>SecureChat 💬</h2>

  <div id="auth-section">
    <input type="text" id="username" placeholder="Username" />
    <input type="password" id="password" placeholder="Password" />
    <button onclick="signup()">Sign Up</button>
    <button onclick="login()">Login</button>
  </div>

  <div id="chat-section" style="display: none;">
    <input type="text" id="searchUser" placeholder="Search users..." oninput="filterUsers()" />
    <select id="recipient"></select>
    <div id="chat-container">
      <div id="message-area"></div>
      <div id="input-area">
        <textarea id="messageInput" rows="2" placeholder="Type a message..."></textarea>
        <button onclick="sendMessage()">Send</button>
        <input type="file" id="fileInput" />
      </div>
    </div>
  </div>

  <script>
    let ws, aesKey, username, publicKey, privateKey;
    let allUsernames = [];

    async function signup() {
      send({ type: 'signup', username: getU(), password: getP() });
    }

    async function login() {
      username = getU();
      const password = getP();
      ws = new WebSocket('wss://localhost:8080');

      ws.onopen = () => {
        console.log('✅ WebSocket connection opened');
        send({ type: 'login', username, password });
      };

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        console.log('📩 Received message:', msg);

        if (msg.type === 'error') return alert(msg.message);
        if (msg.type === 'success') return alert(msg.message);

        if (msg.type === 'login-success') {
          const keyPair = await window.crypto.subtle.generateKey({
            name: 'RSA-OAEP', modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]),
            hash: 'SHA-256'
          }, true, ['encrypt', 'decrypt']);

          publicKey = keyPair.publicKey;
          privateKey = keyPair.privateKey;

          aesKey = await crypto.subtle.generateKey({ name: 'AES-CBC', length: 256 }, true, ['encrypt', 'decrypt']);

          const exportedAES = await crypto.subtle.exportKey('raw', aesKey);
          const importedServerKey = await window.crypto.subtle.importKey(
            'spki', str2ab(atob(msg.publicKey)),
            { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']
          );

          const encryptedKey = await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, importedServerKey, exportedAES);
          send({ type: 'aes-key', encryptedKey: btoa(ab2str(encryptedKey)) });

          //Show chat UI after login
          document.getElementById('auth-section').style.display = 'none';
          document.getElementById('chat-section').style.display = 'block';

          allUsernames = msg.users || [];
          populateRecipientDropdown(allUsernames);
        }

        if (msg.type === 'chat') {
          const buffer = str2ab(atob(msg.encryptedMessage));
          const iv = buffer.slice(0, 16);
          const data = buffer.slice(16);
          const decrypted = await crypto.subtle.decrypt({ name: 'AES-CBC', iv }, aesKey, data);
          const text = new TextDecoder().decode(decrypted);
          const div = document.getElementById('message-area');
          div.innerHTML += `<p><b>${msg.from}:</b> ${formatText(text)}</p>`;
          div.scrollTop = div.scrollHeight;
        }
      };

      ws.onerror = (e) => {
        console.error('❌ WebSocket error:', e);
        alert('WebSocket error. Is the server running?');
      };
    }

    function sendMessage() {
      const text = document.getElementById('messageInput').value;
      if (!text.trim()) return;
      document.getElementById('messageInput').value = '';

      const encoder = new TextEncoder();
      const iv = crypto.getRandomValues(new Uint8Array(16));

      crypto.subtle.encrypt({ name: 'AES-CBC', iv }, aesKey, encoder.encode(text)).then(encrypted => {
        const buffer = new Uint8Array([...iv, ...new Uint8Array(encrypted)]);
        send({ type: 'chat', recipient: document.getElementById('recipient').value, encryptedMessage: btoa(ab2str(buffer)) });
      });
    }

    function getU() { return document.getElementById('username').value; }
    function getP() { return document.getElementById('password').value; }
    function send(obj) { ws.send(JSON.stringify(obj)); }

    function formatText(txt) {
      return txt
        .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
        .replace(/\*(.*?)\*/g, '<i>$1</i>')
        .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');
    }

    function ab2str(buf) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }

    function str2ab(str) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }

    function populateRecipientDropdown(users) {
      const recipientDropdown = document.getElementById('recipient');
      recipientDropdown.innerHTML = '';
      users.forEach(user => {
        const option = document.createElement('option');
        option.value = user;
        option.textContent = user;
        recipientDropdown.appendChild(option);
      });
    }

    function filterUsers() {
      const searchValue = document.getElementById('searchUser').value.toLowerCase();
      const filtered = allUsernames.filter(u => u.toLowerCase().includes(searchValue));
      populateRecipientDropdown(filtered);
    }
  </script>
</body>
</html>
